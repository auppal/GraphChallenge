%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Exact Kronecker Sub-Graph Generator
% Dr. Jeremy Kepner (MIT)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The goal of this script is to enable the fast, parallel, in-memory generation
% of immense power-law Kronecker graphs with exactly computable theoretical properties.
%
% The sub-graph permuations generated by this script can the be used as input into
% ExactKronGenGraph.m or another parallel program to create full graphs
% with known properties.
%
% This script computes and saves the sub-graphs, their size, nnz, triangles,
% and the degree distributions for three types of Kronecker graphs built up
% from star graphs or or B(1,m) bipartite graphs.  The three classes of graphs are:
% Base: has no self-loops, many triangles, power-law degree distribution
% 1: center has a self-loop, many triangles, nearly power-law degree distribution
% 2: leaf has a self-loop, some triangles, nearly power-law degree distribution
%
% NOTE: Requires D4M library to represent hypersparse distributions
%          https://github.com/Accla/d4m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Pick m for B(1,m) bipartite graphs.
% This program will create many different combinations of these that
% can later be pairwised combined to form different real graphs.
% Uncomment *one* set of mm for B(1,m) bipartite graphs.
                                     % Type 1 and 2 edge counts:
mm = [3 4 5 9 16 25 81 256 625];    % 2300e12    edge/vert = 331
%mm = [3 4 5 9 16 25 81 256    ];    %  1.8e12    edge/vert = 165
%mm = [3 4 5 9 16 25 81        ];    %  3.6e9     edge/vert = 83
%mm = [3 4 5 9 16 25           ];    %   22e6     edge/vert = 41
%mm = [3 4 5 9 16              ];    %  434e3     edge/vert = 22

disp(['Sub-graph leaf vertices: ' sprintf('%d ',mm)]);

% Flag for saving the matrices.
SAVEMAT = 0;
SAVETSV = 1;
saveCut = 1e8;    

B  = {};  Bs  = {};  Bt  = {}; Bd  = {};
B1 = {};  B1s = {};  B1t = {}; B1d = {};
B2 = {};  B2s = {};  B2t = {}; B2d = {};

% Create subgraphs.
for i=1:length(mm)
  Bi = bipartite(1,mm(i));                  % Bipartite adjacency matrix.
  B{mm(i)} = Bi;
  Bn{mm(i)} = size(Bi,1);                   % Size.
  Bs{mm(i)} = full(sum(sum(Bi)));           % Sum.
  Bt{mm(i)} = full(sum(sum(Bi*Bi.*Bi)));    % 6 x Triangles (zero for bipartite).
  Bd{mm(i)} = OutDegree(Bi).';

  Bi(1,1) = 1;                             % Set to 1 to create traingles
  B1{mm(i)} = Bi;
  B1s{mm(i)} = full(sum(sum(Bi)));          % Sum.
  B1t{mm(i)} = full(sum(sum(Bi*Bi.*Bi)));   % 6 x Triangles
  B1d{mm(i)} = OutDegree(Bi).';

  Bi(1,1) = 0; Bi(end,end) = 1;            % Set to 1 to create triangles
  B2{mm(i)} = Bi;
  B2s{mm(i)} = full(sum(sum(Bi)));          % Sum.
  B2t{mm(i)} = full(sum(sum(Bi*Bi.*Bi)));   % 6 x Triangles
  B2d{mm(i)} = OutDegree(Bi).';
end


% Create different permutations of mm.
mperm = {};
j = 1;

for imin = 1:(length(mm)-1)
  m1 = mm(imin:end);
  m2 = mm(1:(end-(imin-1)));
  for i = 2:length(m1)
    mperm{j} = m1(1:i);
    disp(['Sub-graph: ' sprintf('%d ',m1(1:i))]);
    j = j + 1;
    mperm{j} = m2((i-1):end);
    disp(['Sub-graph: ' sprintf('%d ',m2((i-1):end))]);
    j = j + 1;
  end
end


A = Assoc('','','');

for im = 1:length(mperm)
  m = mperm{im};

  % Initialize variables for computing macroscopic properties via property
  % KronProd(A1,...,An)*KronProd(B1,...,Bn) = KronProd(A1*B1,...,An*Bn)
  NvertexTheory = Bn{m(1)};
  NedgeTheory = Bs{m(1)};
  NtriTheory = Bt{m(1)};
  [d tmp n] = find(Bd{m(1)});
  dTheory = Assoc(sprintf('%d,',d),'n(d) ',n,@sum);

  N1vertexTheory = Bn{m(1)};
  N1edgeTheory = B1s{m(1)};
  N1triTheory = B1t{m(1)};
  [d tmp n] = find(B1d{m(1)});
  d1Theory = Assoc(sprintf('%d,',d),'n(d) ',n,@sum);

  N2vertexTheory = Bn{m(1)};
  N2edgeTheory = B2s{m(1)};
  N2triTheory = B2t{m(1)};
  [d tmp n] = find(B2d{m(1)});
  d2Theory = Assoc(sprintf('%d,',d),'n(d) ',n,@sum);

  % Recursively compute properties of graphs.
  for i = 2:numel(m)

    % Iteratively compute macroscopic properties.
    NvertexTheory = NvertexTheory.*Bn{m(i)};
    NedgeTheory = NedgeTheory .* Bs{m(i)};
    NtriTheory = NtriTheory .* Bt{m(i)};
    [d  tmp n ] = find(dTheory);
    [di tmp ni] = find(Bd{m(i)});
    dTheory = Assoc(sprintf('%d,',kron(str2num(d),di)),'n(d) ',kron(n,ni),@sum);
 
    N1vertexTheory = N1vertexTheory.*Bn{m(i)};
    N1edgeTheory = N1edgeTheory .* B1s{m(i)};
    N1triTheory = N1triTheory .* B1t{m(i)};
    [d  tmp n ] = find(d1Theory);
    [di tmp ni] = find(B1d{m(i)});
    d1Theory = Assoc(sprintf('%d,',kron(str2num(d),di)),'n(d) ',kron(n,ni),@sum);

    N2vertexTheory = N2vertexTheory.*Bn{m(i)};
    N2edgeTheory = N2edgeTheory .* B2s{m(i)};
    N2triTheory = N2triTheory .* B2t{m(i)};
    [d  tmp n ] = find(d2Theory);
    [di tmp ni] = find(B2d{m(i)});
    d2Theory = Assoc(sprintf('%d,',kron(str2num(d),di)),'n(d) ',kron(n,ni),@sum);
 
  end

  % Remove contribution of B1k(1,1) entry.
  N1edgeTheory = N1edgeTheory - 1;
  N2edgeTheory = N2edgeTheory - 1;

  NtriTheory = NtriTheory/6;

  % Remove contribution of B1k(1,1) entry.
  N1triTheory = N1triTheory/6 - N1vertexTheory/2 + (1/3);
  N2triTheory = N2triTheory/6  - 2^(length(m)-1) + (1/3);

  N2trussTheory = (3.^numel(m) - 3)./2;

  % Remove contribution of B(1,1)
  d1max = max(str2num(Row(d1Theory)));
  d1Theory = (d1Theory - d1Theory(sprintf('%d,',d1max),'n(d) ')) + Assoc(sprintf('%d,',d1max-1),'n(d) ',1);

  d2fix = 2.^length(m);
  d2Theory = (d2Theory - Assoc(sprintf('%d,', d2fix),'n(d) ',1)) + Assoc(sprintf('%d,', d2fix-1),'n(d) ',1);


  rowName = ['Theory' sprintf('-%d',m) ' '];

  % Put into an associative array for display purposes.
  if nnz(A(rowName,:)) == 0
    A = A + Assoc(rowName,'Nvertex Nedge Ntri Nedge/Nvertex N1vertex N1edge N1tri N1edge/N1vertex N2vertex N2edge N2tri N2edge/N2vertex N2truss ',[NvertexTheory NedgeTheory NtriTheory NedgeTheory/NvertexTheory N1vertexTheory N1edgeTheory N1triTheory N1edgeTheory/N1vertexTheory N2vertexTheory N2edgeTheory N2triTheory N2edgeTheory/N2vertexTheory N2trussTheory].');
  end

  Assoc2CSV(dTheory,char(10),char(9),['data/' rowName(1:end-1) '-d.tsv']);

  Assoc2CSV(d1Theory,char(10),char(9),['data/' rowName(1:end-1) '-d1.tsv']);

  Assoc2CSV(d2Theory,char(10),char(9),['data/' rowName(1:end-1) '-d2.tsv']);


  % Save matrices.
  if ((SAVEMAT || SAVETSV) && (Val(A(rowName,'N1edge ')) < saveCut))
    disp(['Saving: data/' rowName(1:end-1)]);
    tic;

    Bk = B{m(1)};
    B1k = B1{m(1)};
    B2k = B2{m(1)};

    for i = 2:numel(m)
      Bk = kron(Bk,B{m(i)});
      B1k = kron(B1k,B1{m(i)});
      B2k = kron(B2k,B2{m(i)});
    end

    B1k(1,1) = 0;

    iB2kLoop = prod((m+1));
    B2k(iB2kLoop, iB2kLoop) = 0;


    if SAVEMAT
      save(['data/' rowName(1:end-1) '-Bk.mat'],'Bk');
      save(['data/' rowName(1:end-1) '-B1k.mat'],'B1k');
      save(['data/' rowName(1:end-1) '-B2k.mat'],'B2k');
    end

    if SAVETSV
      ijv = zeros(3,nnz(Bk));
      [ijv(1,:) ijv(2,:) ijv(3,:)] = find(Bk);
      fid=fopen(['data/' rowName(1:end-1) '-Bk.tsv'],'w');
        fprintf(fid,'%d\t%d\t%d\n',ijv);
      fclose(fid);

      ijv = zeros(3,nnz(B1k));
      [ijv(1,:) ijv(2,:) ijv(3,:)] = find(B1k);
      fid=fopen(['data/' rowName(1:end-1) '-B1k.tsv'],'w');
        fprintf(fid,'%d\t%d\t%d\n',ijv);
      fclose(fid);

      ijv = zeros(3,nnz(B2k));
      [ijv(1,:) ijv(2,:) ijv(3,:)] = find(B2k);
      fid=fopen(['data/' rowName(1:end-1) '-B2k.tsv'],'w');
        fprintf(fid,'%d\t%d\t%d\n',ijv);
      fclose(fid);
    end
    toc

  end

end

Assoc2CSV(A,char(10),char(9),['data/Theory' sprintf('-%d',mm) '.tsv']);

displayFull(A)

